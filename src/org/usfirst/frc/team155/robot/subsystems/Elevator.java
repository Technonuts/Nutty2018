// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team155.robot.subsystems;

import org.usfirst.frc.team155.robot.Robot;
import org.usfirst.frc.team155.robot.RobotMap;
import org.usfirst.frc.team155.robot.commands.*;

import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.VictorSP;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Elevator extends PIDSubsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS


	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	public double setPointScale = 1;
	public double slideSetPoint;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// private final AnalogPotentiometer liftPot = RobotMap.elevatorLiftPot;
	private final WPI_VictorSPX lift_1 = RobotMap.elevatorLift_1;
	//private final WPI_VictorSPX lift_2 = RobotMap.elevatorLift_2;
	private final VictorSP leftHanger = RobotMap.elevatorLeftHanger;
	private final VictorSP rightHanger = RobotMap.elevatorRightHanger;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public final Encoder liftEncoder = RobotMap.elevatorLiftEncoder;

	private final DigitalInput maxLimit = RobotMap.elevatorSwitchHigh;
	private final DigitalInput minLimit = RobotMap.elevatorSwitchLow;
	private final DigitalInput hangingSwitch = RobotMap.hangingSwitch;
	// Initialize your subsystem here
	public Elevator() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
		super("Elevator", 1.0, 0.0, 0.0);
		setAbsoluteTolerance(0.05);
		getPIDController().setContinuous(false);
		LiveWindow.addActuator("Elevator", "PIDSubsystem Controller", getPIDController());
		LiveWindow.addSensor("Elevator", "liftEncoder", liftEncoder);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

		// Use these to get going:
		// setSetpoint() - Sets where the PID controller should move the system
		// to
		// enable() - Enables the PID controller.
	}

	@Override
	public void initDefaultCommand() {
		lift_1.setNeutralMode(com.ctre.phoenix.motorcontrol.NeutralMode.Brake);
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new manualMoveLift());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	@Override
	protected double returnPIDInput() {
		// Return your input value for the PID loop
		// e.g. a sensor, like a potentiometer:
		// yourPot.getAverageVoltage() / kYourMaxVoltage;
		System.out.println(" elevator height =" + liftEncoder.getDistance());
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
		return liftEncoder.getDistance();

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
	}

	@Override
	protected void usePIDOutput(double output) {
		// Use output to drive your system, like a motor
		// e.g. yourMotor.set(output);

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
		lift_1.pidWrite(output);
		//lift_2.pidWrite(output);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT

	}

	public Encoder getLiftEncoder() {
		return liftEncoder;
	}

	public double sliderValue(Joystick Switch) {
		slideSetPoint = Switch.getAxis(Joystick.AxisType.kY) * setPointScale;
		return slideSetPoint;
	}

	public boolean getHighLimit() {
		return maxLimit.get();
	}

	public boolean getLowLimit() {
		return minLimit.get();
	}

	public void resetLow() {
		if (getLowLimit()) {
			liftEncoder.reset();
		}
	}

	public void manualLift(Joystick Switch) {
		lift_1.set(Switch.getAxis(Joystick.AxisType.kY));
		//lift_2.set(Switch.getAxis(Joystick.AxisType.kY));
	}

	public void holdLift() {
		lift_1.set(0); /// Change value to have it hold
		//lift_2.set(0);

	}
	public double getHeight() {
		return liftEncoder.getDistance();
	}
	public boolean getClimbSwitch() {
		return hangingSwitch.get();
	}
	

/*	public void holdLiftWithPower(double power) {
		if (Robot.oi.switches.getAxis(Joystick.AxisType.kY) == 0) {
			lift_1.set(power);
			//lift_2.set(power);
		}
		

	}
*/
}
